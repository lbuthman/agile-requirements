"The most important piece of information on a requirements document is the phone number of the person that wrote it."

- Instead of handing down incomplete abstract requirements, the focus should be on facilitating the flow of information,
allowing people to work out for themselves when they understand each other correctly.

- By writing black-box, functional tests up front, technical details of the solution are gotten to immediately and the
space separating requirements and tests becomes thin to none. This leads to the idea of Examples which can become
Tests which then verify requirements. Examples also elaborate Requirements.

- It is critical to help each other, business/customer/technical understand the problem better. It is possible that
what is being asked is based on limited information on either side. The example of printing physical copies to share
data between applicaitons was used here.

- Mission Command in the Army -> Why something needs to be done as a contrast to Imperative Command, saying What
needs to be done

- Remember the example of the "real-time" scenario. The moral is to not take requirements at face value especially
if they come in a solution form that omits intent.

- All of the problems and solutions mentioned previously dovetail into Agile Acceptance Testing which revolves around
5 key ideas
  1) Use real-world examples to build a shared understanding of the domain.
  2) Select a set of these examples to be a specificaiton and acceptance testing suite.
  3) Automate verification of the acceptance tests.
  4) Focus the software development effort on the acceptance tests.
  5) Use the set of acceptance tests to facilitate discussion about future change requests, effectively going back
  to step 1 for a new cycle of development.
  
- Unit testing in TDD has been very successful, allowing teams to focus on what a system should do, clarify a target,
facilitate better team work, and hold the system together during changes. This benefit was naturally desired to
extend to validating Business Rules, but business domain experts most likely do not understand programming
languages. Developers could write Unit Tests based on these Business Rules, but would still suffer the same problems
discussed in Ch. 1. Creating better ways for specifying and automating tests for business rules lead to tools that
focus on the customer's view of how the finished system should work. This is where the term Agile Acceptance
Testing comes from. The problem is essentially a communication problem, not a technical problem.

- To mitigate the negative implications of "testing" and avoid confusion with UAT, the name is sometimes called
Acceptance Test Driven Development, Functional Test Driven Development, Test Driven Requirements, and Behavior
Driven Development. In addition, Example Driven Development is used with tests being called Specification by Example.
